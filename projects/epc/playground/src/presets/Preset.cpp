#include <utility>
#include <presets/Preset.h>
#include "Bank.h"
#include <presets/PresetManager.h>
#include "PresetParameter.h"
#include "PresetParameterGroup.h"
#include <serialization/PresetSerializer.h>
#include <Application.h>
#include <device-settings/DebugLevel.h>
#include <device-settings/DeviceName.h>
#include <device-settings/Settings.h>
#include <device-info/DeviceInformation.h>
#include <tools/TimeTools.h>
#include <presets/EditBuffer.h>
#include <nltools/Types.h>
#include <groups/ParameterGroup.h>
#include <giomm/file.h>
#include <http/UpdateDocumentMaster.h>
#include <sync/JsonAdlSerializers.h>

Preset::Preset(UpdateDocumentContributor *parent)
    : super(parent)
    , SyncedItem(parent->getRoot()->getSyncMaster())
    , m_name("New Preset")
    , m_voiceGroupLabels { { "", "" } }
{
  setTopic("/preset/" + m_uuid.raw());
}

Preset::Preset(UpdateDocumentContributor *parent, const Preset &other)
    : super(parent, other)
    , SyncedItem(parent->getRoot()->getSyncMaster())
    , m_name(other.m_name)
    , m_voiceGroupLabels { other.m_voiceGroupLabels }
{
  setTopic("/preset/" + m_uuid.raw());
}

Preset::Preset(UpdateDocumentContributor *parent, const EditBuffer &editBuffer)
    : Preset(parent, editBuffer, Uuid())
{
}

Preset::Preset(UpdateDocumentContributor *parent, const EditBuffer &editBuffer, Uuid uuid)
    : super(parent, editBuffer)
    , SyncedItem(parent->getRoot()->getSyncMaster(), "/preset/" + uuid.raw())
{
  setTopic("/preset/" + m_uuid.raw());

  m_name = editBuffer.getName();
  m_voiceGroupLabels[0] = editBuffer.getVoiceGroupName(VoiceGroup::I);
  m_voiceGroupLabels[1] = editBuffer.getVoiceGroupName(VoiceGroup::II);

  m_originDescription = editBuffer.getPresetOriginDescription();
}

Preset::~Preset()
{
  if(auto pm = dynamic_cast<PresetManager *>(getParent()))
    if(auto eb = pm->getEditBuffer())
      eb->resetOriginIf(this);
}

void Preset::load(UNDO::Transaction *transaction, const Glib::RefPtr<Gio::File> &presetPath)
{
  auto strUUID = getUuid();
  Serializer::read<PresetSerializer>(transaction, presetPath, strUUID.raw(), this);
  m_lastSavedUpdateID = getUpdateIDOfLastChange();
}

bool Preset::save(const Glib::RefPtr<Gio::File> &bankPath)
{
  if(m_lastSavedUpdateID != getUpdateIDOfLastChange())
  {
    PresetSerializer serializer(this, {});
    auto strUUID = getUuid().raw();
    serializer.write(bankPath, strUUID);
    m_lastSavedUpdateID = getUpdateIDOfLastChange();
    return true;
  }
  return false;
}

UpdateDocumentContributor::tUpdateID Preset::onChange(uint64_t flags)
{
  auto ret = AttributesOwner::onChange(flags);
  m_onChanged.send();
  setDirty();
  return ret;
}

void Preset::setAttribute(UNDO::Transaction *transaction, const std::string &key, const Glib::ustring &value)
{
  super::setAttribute(transaction, key, value);
  setAutoGeneratedAttributes(transaction);

  auto eb = getEditBuffer();

  if(eb && eb->getUUIDOfLastLoadedPreset() == getUuid() && !eb->isModified())
    eb->setAttribute(transaction, key, value);
}

EditBuffer *Preset::getEditBuffer() const
{
  if(Application::exists())
    return Application::get().getPresetManager()->getEditBuffer();

  return nullptr;
}

void Preset::clear(UNDO::Transaction *transaction)
{
  super::clear(transaction);
  setAutoGeneratedAttributes(transaction);
}

void Preset::invalidate()
{
  onChange(ChangeFlags::Generic);
}

void Preset::updateBanksLastModifiedTimestamp(UNDO::Transaction *transaction)
{
  if(auto bank = dynamic_cast<Bank *>(getParent()))
    bank->updateLastModifiedTimestamp(transaction);
}

Glib::ustring Preset::getVoiceGroupName(VoiceGroup vg) const
{
  return m_voiceGroupLabels[static_cast<size_t>(vg)];
}

void Preset::undoableSetVoiceGroupName(UNDO::Transaction *transaction, VoiceGroup vg, const Glib::ustring &name)
{
  nltools_assertAlways(vg == VoiceGroup::I || vg == VoiceGroup::II);
  transaction->addUndoSwap(this, m_voiceGroupLabels[static_cast<size_t>(vg)], name);
}

Glib::ustring Preset::getDisplayNameWithSuffixes(bool addSpace) const
{
  auto mono = isMonoActive();
  auto unison = isUnisonActive();
  return getName() + (addSpace ? "\u202F" : "") + (mono ? "\uE040" : "") + (unison ? "\uE041" : "");
}

Glib::ustring Preset::getName() const
{
  return m_name;
}

const Uuid &Preset::getUuid() const
{
  return m_uuid;
}

void Preset::setUuid(UNDO::Transaction *transaction, const Uuid &uuid)
{
  auto s = UNDO::createSwapData(uuid);

  transaction->addSimpleCommand([this, s](auto) {
    s->swapWith(m_uuid);
    SyncedItem::setTopic("/preset/" + m_uuid.raw());
  });

  setAutoGeneratedAttributes(transaction);
}

void Preset::setName(UNDO::Transaction *transaction, const Glib::ustring &name)
{
  transaction->addUndoSwap(this, m_name, name);
  setAutoGeneratedAttributes(transaction);
}

void Preset::setType(UNDO::Transaction *transaction, SoundType type)
{
  super::setType(transaction, type);
  setAutoGeneratedAttributes(transaction);
}

void Preset::guessName(UNDO::Transaction *transaction)
{
  auto currentName = getName();

  if(currentName.empty())
    currentName = "New preset";

  setName(transaction, Application::get().getPresetManager()->createPresetNameBasedOn(currentName));
}

void Preset::copyFrom(UNDO::Transaction *transaction, const Preset *other)
{
  super::copyFrom(transaction, other);

  setName(transaction, other->getName());
  undoableSetVoiceGroupName(transaction, VoiceGroup::I, other->getVoiceGroupName(VoiceGroup::I));
  undoableSetVoiceGroupName(transaction, VoiceGroup::II, other->getVoiceGroupName(VoiceGroup::II));

  setAutoGeneratedAttributes(transaction);
}

void Preset::copyFrom(UNDO::Transaction *transaction, EditBuffer *edit)
{
  super::copyFrom(transaction, edit);
  setName(transaction, edit->getName());
  undoableSetVoiceGroupName(transaction, VoiceGroup::I, edit->getVoiceGroupName(VoiceGroup::I));
  undoableSetVoiceGroupName(transaction, VoiceGroup::II, edit->getVoiceGroupName(VoiceGroup::II));
  setAutoGeneratedAttributes(transaction);
  getEditBuffer()->undoableSetLoadedPresetInfo(transaction, this);
}

void Preset::setAutoGeneratedAttributes(UNDO::Transaction *transaction)
{
  if(m_autoGeneratedAttributesLockCount != 0)
    return;

  if(Application::exists())
  {
    super::setAttribute(transaction, "DeviceName", Application::get().getSettings()->getSetting<DeviceName>()->get());
    super::setAttribute(transaction, "StoreTime", TimeTools::getAdjustedIso());
    super::setAttribute(transaction, "SoftwareVersion",
                        Application::get().getDeviceInformation()->getSoftwareVersion());

    updateBanksLastModifiedTimestamp(transaction);
  }
}

Glib::ustring Preset::buildUndoTransactionTitle(const Glib::ustring &prefix) const
{
  if(auto bank = dynamic_cast<const Bank *>(getParent()))
  {
    if(auto pm = dynamic_cast<const PresetManager *>(bank->getParent()))
    {
      auto bankNumber = pm->getBankPosition(bank->getUuid()) + 1;
      auto presetNumber = bank->getPresetPosition(getUuid()) + 1;

      char txt[256];
      sprintf(txt, "%lu-%03lu", bankNumber, presetNumber);
      return UNDO::StringTools::buildString(prefix, " ", toString(getType()), " Preset ", txt, ": '", getName(), "'");
    }
  }

  return UNDO::StringTools::buildString(prefix, " '", getName(), "'");
}

bool Preset::matchesQuery(const SearchQuery &query) const
{
  return query.iterate([&](const auto &part, const auto &fields) {
    static_assert(static_cast<int>(SearchQuery::Fields::Name) == 0, "");
    static_assert(static_cast<int>(SearchQuery::Fields::Comment) == 1, "");
    static_assert(static_cast<int>(SearchQuery::Fields::DeviceName) == 2, "");

    std::array<Glib::ustring, 3> entries = { getName().lowercase(), getAttribute("Comment", "").lowercase(),
                                             getAttribute("DeviceName", "").lowercase() };

    for(const auto f : fields)
    {
      if(entries[static_cast<size_t>(f)].find(part) != Glib::ustring::npos)
      {
        return true;
      }
    }
    return false;
  });
}

void Preset::lockAutoGeneratedAttributes()
{
  m_autoGeneratedAttributesLockCount++;
}

void Preset::unlockAutoGeneratedAttributes()
{
  m_autoGeneratedAttributesLockCount--;
}

sigc::connection Preset::onChanged(sigc::slot<void> cb)
{
  return m_onChanged.connectAndInit(cb);
}

void Preset::writeDocument(Writer &writer, UpdateDocumentContributor::tUpdateID knownRevision) const
{
  bool changed = knownRevision < getUpdateIDOfLastChange();

  writer.writeTag("preset",
                  {
                      Attribute("uuid", getUuid().raw()),
                      Attribute("name", m_name),
                      Attribute("name-suffixed", getDisplayNameWithSuffixes(true)),
                      Attribute("changed", changed),
                      Attribute("type", toString(getType())),
                      Attribute("part-I-name", getVoiceGroupName(VoiceGroup::I)),
                      Attribute("part-II-name", getVoiceGroupName(VoiceGroup::II)),
                  },
                  [&]() {
                    if(changed)
                    {
                      AttributesOwner::writeDocument(writer, knownRevision);
                    }
                  });
}

void Preset::writeDiff(Writer &writer, const Preset *other, VoiceGroup vgOfThis, VoiceGroup vgOfOther) const
{
  auto pm = Application::get().getPresetManager();

  auto posString = [&](const Preset *p) {
    std::string ret;
    if(auto b = dynamic_cast<Bank *>(p->getParent()))
    {
      char txt[256];
      sprintf(txt, "%lu-%03lu", pm->getBankPosition(b->getUuid()) + 1, b->getPresetPosition(p->getUuid()) + 1);
      ret = txt;
    }
    else
      ret = "Edit Buffer";
    return ret;
  };

  auto eb = pm->getEditBuffer();
  const auto ebUUID = eb->getUUIDOfLastLoadedPreset();

  auto getButtonStatesPresets = [&](const Preset *p, const Preset *other) {
    std::pair<bool, bool> active;
    auto ebChanged = eb->isModified();
    active.first = p->getUuid() != ebUUID || ebChanged;
    active.second = other->getUuid() != ebUUID || ebChanged;
    return active;
  };

  auto getButtonStates = [&](const Preset *p, const Preset *) {
    std::pair<bool, bool> active;
    auto isLoaded = (p->getUuid() == ebUUID);
    active.first = !isLoaded || eb->isModified();
    active.second = eb->isModified() & !active.first;
    return active;
  };

  writer.writeTag("diff", [&] {
    std::pair<bool, bool> buttonStates;
    if(posString(this) == "Edit Buffer" || posString(other) == "Edit Buffer")
      buttonStates = getButtonStates(this, other);
    else
      buttonStates = getButtonStatesPresets(this, other);

    writer.writeTextElement("position", "", Attribute("a", posString(this)), Attribute("b", posString(other)));
    writer.writeTextElement("name", "", Attribute("a", getName()), Attribute("b", other->getName()));
    writer.writeTextElement("vgI-name", "", Attribute("a", getVoiceGroupName(VoiceGroup::I)),
                            Attribute("b", other->getVoiceGroupName(VoiceGroup::I)));
    writer.writeTextElement("vgII-name", "", Attribute("a", getVoiceGroupName(VoiceGroup::II)),
                            Attribute("b", other->getVoiceGroupName(VoiceGroup::II)));
    writer.writeTextElement("enabled", "", Attribute("a", buttonStates.first), Attribute("b", buttonStates.second));

    super::writeDiff(writer, other);

    writeGroups(writer, other, vgOfThis, vgOfOther);
    writeGroups(writer, other, VoiceGroup::Global, VoiceGroup::Global);
  });
}

bool Preset::isMonoActive() const
{
  auto monoEnabledI = findParameterByID({ 364, VoiceGroup::I }, false);
  auto monoEnabledII = findParameterByID({ 364, VoiceGroup::II }, false);

  if(monoEnabledI && monoEnabledII)
  {
    if(getType() == SoundType::Split)
    {
      return monoEnabledI->getValue() > 0 || monoEnabledII->getValue() > 0;
    }
    else
    {
      return monoEnabledI->getValue() > 0;
    }
  }

  return false;
}

bool Preset::isUnisonActive() const
{
  auto unisonVoicesI = findParameterByID({ 249, VoiceGroup::I }, false);
  auto unisonVoicesII = findParameterByID({ 249, VoiceGroup::II }, false);

  if(unisonVoicesI)
  {
    if(getType() == SoundType::Split && unisonVoicesII)
    {
      return unisonVoicesI->getValue() > 0 || unisonVoicesII->getValue() > 0;
    }
    else
    {
      return unisonVoicesI->getValue() > 0;
    }
  }

  return false;
}

bool Preset::isDual() const
{
  return getType() == SoundType::Split || getType() == SoundType::Layer;
}

Glib::ustring Preset::getComment()
{
  return getAttribute("Comment", "");
}

std::optional<std::string> Preset::getOriginDescription() const
{
  return m_originDescription;
}

nlohmann::json Preset::serialize() const
{
  auto bank = dynamic_cast<Bank *>(getParent());

  if(!bank || bank->findPreset(m_uuid) != this)
    return nullptr;

  return { { "uuid", m_uuid },
           { "bank-uuid", bank ? bank->getUuid() : Uuid::none() },
           { "name", m_name },
           { "name-suffixed", getDisplayNameWithSuffixes(true) },
           { "type", toString(getType()) },
           { "part-I-name", getVoiceGroupName(VoiceGroup::I) },
           { "part-II-name", getVoiceGroupName(VoiceGroup::II) },
           { "attributes", AttributesOwner::toJson() } };
}

Glib::ustring Preset::getTypeUnicode() const
{
  if(getType() == SoundType::Split)
    return "\uE0F1";
  else if(getType() == SoundType::Layer)
    return "\uE0F4";
  else
    return "";
}
